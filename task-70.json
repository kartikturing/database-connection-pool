{
  "prompt": "Database Connection Pool Configuration - LLM Query\nTask Request\nPlease create a high-performance database connection pool implementation using HikariCP (the default connection pool in Spring Boot 2+) in a Spring Boot application. The implementation should focus on optimizing database connectivity through proper configuration of key performance and reliability properties, comprehensive testing, and production-ready monitoring.\n\nRequirements to Implement\n1. HikariCP Configuration Properties\nPlease configure HikariCP with the following properties:\n\nProduction Configuration (application.properties):\n\nmaximum-pool-size: 20 connections for high-throughput applications\nminimum-idle: 5 connections to maintain baseline availability\nconnection-timeout: 20000ms (20 seconds) for reasonable wait times\nmax-lifetime: 1200000ms (20 minutes) for connection freshness\nidle-timeout: 300000ms (5 minutes) for efficient resource usage\nleak-detection-threshold: 60000ms (1 minute) for development debugging\nvalidation-timeout: 5000ms for quick connection validation\nauto-commit: true for default transaction behavior\nconnection-test-query: \"SELECT 1\" for connection validation\nregister-mbeans: true for JMX monitoring\npool-name: \"HikariCP-Production\" for identification\nTest Configuration (application-test.properties):\n\nOptimize for faster test execution with smaller pool sizes\nmaximum-pool-size: 5, minimum-idle: 2\nReduce timeouts for quicker test feedback\n2. Spring Boot Integration\nPlease implement the following Spring Boot integration:\n\nSingle File Architecture: Consolidate all components in DatabaseConnectionPoolApplication.java\nConfiguration Properties Binding: Use @ConfigurationProperties(\"spring.datasource.hikari\")\nAuto-Configuration: Leverage Spring Boot's HikariCP auto-configuration\nComponent Organization: Create the following components:\nHikariProperties: Configuration properties class\nDatabaseConfig: HikariDataSource bean configuration\nDatabaseHealthIndicator: Custom health monitoring\nConnectionPoolEndpoint: Custom actuator endpoint\nDatabaseTestController: REST endpoints for testing\n3. Database Integration\nPlease set up database integration with:\n\nH2 In-Memory Database: For development and testing\nJDBC Template Integration: For database operations\nConnection Validation: Implement automatic connection health checks\nMulti-Environment Support: Create separate configurations for production and test\n4. Monitoring and Diagnostics\nPlease implement monitoring and diagnostics with:\n\nJMX Monitoring: Enable for production monitoring\nCustom Health Indicator: Create /actuator/health endpoint with database status\nCustom Actuator Endpoint: Implement /actuator/connectionpool with detailed metrics\nConnection Pool Metrics: Include the following metrics:\nActive connections count\nTotal connections count\nPool utilization percentage\nPool health status\nPool name and configuration details\n5. REST API Endpoints\nPlease create the following REST API endpoints:\n\n/test-db: Database connectivity test with connection details\n/load-test: Connection pool load testing (10 concurrent operations)\n/pool-status: Detailed pool status and utilization metrics\n/actuator/health: Spring Boot health endpoint with database status\n/actuator/connectionpool: Custom endpoint with comprehensive pool metrics\n6. Comprehensive Test Suite\nPlease create a comprehensive test suite with 25 Test Methods Organized in 7 Categories:\n\nHikariCP Properties Tests (4 tests)\n\nDefault pool size settings validation\nDefault timeout settings validation\nDefault reliability settings validation\nProperty setters/getters validation\nDatabase Configuration Tests (5 tests)\n\nHikariDataSource bean creation\nConfiguration properties validation\nDatabase connection establishment\nDatabase operations execution\nMultiple concurrent connections handling\nHealth Indicator Tests (3 tests)\n\nHealthy database status reporting\nHikariCP metrics inclusion in health details\nUnhealthy database status handling\nREST Controller Tests (4 tests)\n\nDatabase connectivity endpoint testing\nLoad test endpoint validation\nPool status endpoint verification\nConcurrent request handling\nActuator Endpoint Tests (5 tests)\n\nConnection pool endpoint availability\nComprehensive metrics validation\nHealth endpoint integration\nDatabase health component verification\nDirect endpoint method testing\nPerformance Tests (5 tests)\n\nConcurrent connection request efficiency\nConnection pool exhaustion handling\nConnection reuse efficiency demonstration\nRapid connection cycling performance\nMixed workload pool health maintenance\nIntegration Tests (2 tests)\n\nComplete application integration validation\nConfiguration consistency across components\n7. Performance Optimizations\nPlease implement the following performance optimizations:\n\nPool Size Calculation: Optimize for typical web application loads\nConnection Lifetime Management: Balance for performance and resource efficiency\nTimeout Configuration: Prevent resource starvation while maintaining responsiveness\nLeak Detection: Enable for development debugging\nConnection Validation: Ensure connection reliability\n8. Production Readiness Features\nPlease ensure the following production readiness features:\n\nEnvironment-Specific Configuration: Create separate settings for production and test\nComprehensive Monitoring: Implement health checks, metrics, and JMX integration\nError Handling: Provide graceful degradation and proper error reporting\nResource Management: Ensure efficient connection pooling and cleanup\nObservability: Include detailed logging and metrics collection\nTechnical Implementation Specifications\nMaven Configuration (pom.xml)\nPlease set up Maven configuration with:\n\nSpring Boot 3.2.0 parent\nDependencies: Web, JDBC, Actuator, HikariCP, H2, JUnit 5, Mockito\nJava 17 compatibility\nMaven Surefire Plugin for testing\nTesting Strategy\nPlease implement the following testing strategy:\n\nUnit Tests: Individual component validation\nIntegration Tests: End-to-end application testing\nPerformance Tests: Connection pool behavior under load\nHTTP Tests: REST endpoint validation with TestRestTemplate\nMock Testing: Error condition simulation\nBuild and Validation\nPlease provide:\n\nMaven Build System: Complete project lifecycle management\nAutomated Testing: Comprehensive test suite execution\nValidation Script: run_and_validate.sh for complete project validation\nContinuous Integration Ready: All tests automated and reproducible\nExpected Skills to Demonstrate\nThe implementation should demonstrate:\n\nDatabase Connection Pooling: Advanced HikariCP configuration and optimization\nSpring Boot Mastery: Auto-configuration, properties binding, actuator integration\nPerformance Tuning: Optimal settings for high-performance applications\nProduction Readiness: Monitoring, health checks, and observability\nTesting Excellence: Comprehensive test coverage with multiple testing strategies\nResource Management: Efficient database resource utilization\nAPI Design: RESTful endpoints for testing and monitoring\nConfiguration Management: Environment-specific settings and property binding\nExpected Project Structure\nPlease create the following project structure:\n\ndatabase-connection-pool/\n├── pom.xml\n├── detailed-prompt.md\n├── run_and_validate.sh\n├── src/\n│   ├── main/\n│   │   ├── java/com/example/connectionpool/\n│   │   │   └── DatabaseConnectionPoolApplication.java\n│   │   └── resources/\n│   │       └── application.properties\n│   └── test/\n│       ├── java/com/example/connectionpool/\n│       │   └── DatabaseConnectionPoolApplicationTest.java\n│       └── resources/\n│           └── application-test.properties\n└── target/ (generated)\nDeliverable\nPlease provide a production-ready, high-performance database connection pool with comprehensive testing, monitoring, and optimization features that demonstrate enterprise-level Spring Boot application development skills.",
  "language": "java",
  "ground": "```java\n\npackage com.example.connectionpool;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.actuate.endpoint.annotation.Endpoint;\nimport org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\nimport org.springframework.boot.actuate.health.Health;\nimport org.springframework.boot.actuate.health.HealthIndicator;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.sql.DataSource;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Spring Boot Application demonstrating high-performance HikariCP database connection pool configuration.\n * <p>\n * This application showcases:\n * 1. Programmatic HikariCP configuration with optimized settings\n * 2. Custom configuration properties binding\n * 3. Database health monitoring and diagnostics\n * 4. Connection pool metrics and monitoring endpoints\n * 5. Production-ready connection pool setup\n * <p>\n * Key Performance Features:\n * - Optimized pool sizing based on application load\n * - Proper timeout configuration for reliability\n * - Connection leak detection for debugging\n * - JMX monitoring for production observability\n * - Custom validation queries for connection health\n *\n * @author Database Performance Team\n * @version 1.0\n */\n@SpringBootApplication\n@EnableConfigurationProperties(DatabaseConnectionPoolApplication.HikariProperties.class)\npublic class DatabaseConnectionPoolApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DatabaseConnectionPoolApplication.class, args);\n    }\n\n    /**\n     * Custom configuration properties for HikariCP.\n     * These properties can be overridden in application.properties or application.yml\n     */\n    @ConfigurationProperties(prefix = \"app.datasource.hikari\")\n    public static class HikariProperties {\n\n        // Core pool settings\n        private int maximumPoolSize = 20;           // Optimized for moderate load\n        private int minimumIdle = 5;                // Maintain minimum connections\n\n        // Timeout configuration (in milliseconds)\n        private long connectionTimeout = 20000;     // 20 seconds - faster than default\n        private long maxLifetime = 1200000;         // 20 minutes - shorter than default\n        private long idleTimeout = 300000;          // 5 minutes idle timeout\n        private long validationTimeout = 5000;      // 5 seconds validation\n\n        // Performance and reliability settings\n        private long leakDetectionThreshold = 60000; // 1 minute leak detection\n        private boolean autoCommit = true;\n        private String connectionTestQuery = \"SELECT 1\";\n\n        // JMX and monitoring\n        private boolean registerMbeans = true;\n        private String poolName = \"HikariCP-Primary\";\n\n        // Database connection settings\n        private String jdbcUrl = \"jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE\";\n        private String username = \"sa\";\n        private String password = \"\";\n        private String driverClassName = \"org.h2.Driver\";\n\n        // Getters and setters\n        public int getMaximumPoolSize() {\n            return maximumPoolSize;\n        }\n\n        public void setMaximumPoolSize(int maximumPoolSize) {\n            this.maximumPoolSize = maximumPoolSize;\n        }\n\n        public int getMinimumIdle() {\n            return minimumIdle;\n        }\n\n        public void setMinimumIdle(int minimumIdle) {\n            this.minimumIdle = minimumIdle;\n        }\n\n        public long getConnectionTimeout() {\n            return connectionTimeout;\n        }\n\n        public void setConnectionTimeout(long connectionTimeout) {\n            this.connectionTimeout = connectionTimeout;\n        }\n\n        public long getMaxLifetime() {\n            return maxLifetime;\n        }\n\n        public void setMaxLifetime(long maxLifetime) {\n            this.maxLifetime = maxLifetime;\n        }\n\n        public long getIdleTimeout() {\n            return idleTimeout;\n        }\n\n        public void setIdleTimeout(long idleTimeout) {\n            this.idleTimeout = idleTimeout;\n        }\n\n        public long getValidationTimeout() {\n            return validationTimeout;\n        }\n\n        public void setValidationTimeout(long validationTimeout) {\n            this.validationTimeout = validationTimeout;\n        }\n\n        public long getLeakDetectionThreshold() {\n            return leakDetectionThreshold;\n        }\n\n        public void setLeakDetectionThreshold(long leakDetectionThreshold) {\n            this.leakDetectionThreshold = leakDetectionThreshold;\n        }\n\n        public boolean isAutoCommit() {\n            return autoCommit;\n        }\n\n        public void setAutoCommit(boolean autoCommit) {\n            this.autoCommit = autoCommit;\n        }\n\n        public String getConnectionTestQuery() {\n            return connectionTestQuery;\n        }\n\n        public void setConnectionTestQuery(String connectionTestQuery) {\n            this.connectionTestQuery = connectionTestQuery;\n        }\n\n        public boolean isRegisterMbeans() {\n            return registerMbeans;\n        }\n\n        public void setRegisterMbeans(boolean registerMbeans) {\n            this.registerMbeans = registerMbeans;\n        }\n\n        public String getPoolName() {\n            return poolName;\n        }\n\n        public void setPoolName(String poolName) {\n            this.poolName = poolName;\n        }\n\n        public String getJdbcUrl() {\n            return jdbcUrl;\n        }\n\n        public void setJdbcUrl(String jdbcUrl) {\n            this.jdbcUrl = jdbcUrl;\n        }\n\n        public String getUsername() {\n            return username;\n        }\n\n        public void setUsername(String username) {\n            this.username = username;\n        }\n\n        public String getPassword() {\n            return password;\n        }\n\n        public void setPassword(String password) {\n            this.password = password;\n        }\n\n        public String getDriverClassName() {\n            return driverClassName;\n        }\n\n        public void setDriverClassName(String driverClassName) {\n            this.driverClassName = driverClassName;\n        }\n    }\n\n    /**\n     * Database configuration class that creates and configures the HikariCP DataSource.\n     */\n    @Configuration\n    public static class DatabaseConfig {\n\n        private final HikariProperties hikariProperties;\n\n        public DatabaseConfig(HikariProperties hikariProperties) {\n            this.hikariProperties = hikariProperties;\n        }\n\n        /**\n         * Creates a high-performance HikariCP DataSource with optimized configuration.\n         * <p>\n         * Configuration Rationale:\n         * - maximumPoolSize: Set based on expected concurrent database operations\n         * - minimumIdle: Maintains ready connections for immediate use\n         * - connectionTimeout: Prevents long waits for connections\n         * - maxLifetime: Ensures connection freshness and prevents stale connections\n         * - leakDetectionThreshold: Helps identify connection leaks in development\n         *\n         * @return Configured HikariDataSource\n         */\n        @Bean\n        @Primary\n        public DataSource dataSource() {\n            HikariConfig config = new HikariConfig();\n\n            // Database connection settings\n            config.setJdbcUrl(hikariProperties.getJdbcUrl());\n            config.setUsername(hikariProperties.getUsername());\n            config.setPassword(hikariProperties.getPassword());\n            config.setDriverClassName(hikariProperties.getDriverClassName());\n\n            // Core pool configuration\n            config.setMaximumPoolSize(hikariProperties.getMaximumPoolSize());\n            config.setMinimumIdle(hikariProperties.getMinimumIdle());\n\n            // Timeout configuration\n            config.setConnectionTimeout(hikariProperties.getConnectionTimeout());\n            config.setMaxLifetime(hikariProperties.getMaxLifetime());\n            config.setIdleTimeout(hikariProperties.getIdleTimeout());\n            config.setValidationTimeout(hikariProperties.getValidationTimeout());\n\n            // Performance and reliability settings\n            config.setLeakDetectionThreshold(hikariProperties.getLeakDetectionThreshold());\n            config.setAutoCommit(hikariProperties.isAutoCommit());\n            config.setConnectionTestQuery(hikariProperties.getConnectionTestQuery());\n\n            // Monitoring and JMX\n            config.setRegisterMbeans(hikariProperties.isRegisterMbeans());\n            config.setPoolName(hikariProperties.getPoolName());\n\n            // Additional performance optimizations\n            config.addDataSourceProperty(\"cachePrepStmts\", \"true\");\n            config.addDataSourceProperty(\"prepStmtCacheSize\", \"250\");\n            config.addDataSourceProperty(\"prepStmtCacheSqlLimit\", \"2048\");\n            config.addDataSourceProperty(\"useServerPrepStmts\", \"true\");\n            config.addDataSourceProperty(\"useLocalSessionState\", \"true\");\n            config.addDataSourceProperty(\"rewriteBatchedStatements\", \"true\");\n            config.addDataSourceProperty(\"cacheResultSetMetadata\", \"true\");\n            config.addDataSourceProperty(\"cacheServerConfiguration\", \"true\");\n            config.addDataSourceProperty(\"elideSetAutoCommits\", \"true\");\n            config.addDataSourceProperty(\"maintainTimeStats\", \"false\");\n\n            return new HikariDataSource(config);\n        }\n\n        /**\n         * JdbcTemplate bean for database operations\n         */\n        @Bean\n        public JdbcTemplate jdbcTemplate(DataSource dataSource) {\n            return new JdbcTemplate(dataSource);\n        }\n    }\n\n    /**\n     * Health indicator for database connectivity monitoring.\n     * Provides detailed health information about the database connection pool.\n     */\n    @Component\n    public static class DatabaseHealthIndicator implements HealthIndicator {\n\n        private final DataSource dataSource;\n        private final JdbcTemplate jdbcTemplate;\n\n        public DatabaseHealthIndicator(DataSource dataSource, JdbcTemplate jdbcTemplate) {\n            this.dataSource = dataSource;\n            this.jdbcTemplate = jdbcTemplate;\n        }\n\n        @Override\n        public Health health() {\n            try {\n                // Test database connectivity\n                jdbcTemplate.queryForObject(\"SELECT 1\", Integer.class);\n\n                // Get HikariCP metrics if available\n                Health.Builder builder = Health.up()\n                        .withDetail(\"database\", \"Available\")\n                        .withDetail(\"validationQuery\", \"SELECT 1\");\n\n                if (dataSource instanceof HikariDataSource) {\n                    HikariDataSource hikariDataSource = (HikariDataSource) dataSource;\n                    builder.withDetail(\"poolName\", hikariDataSource.getPoolName())\n                            .withDetail(\"activeConnections\", hikariDataSource.getHikariPoolMXBean().getActiveConnections())\n                            .withDetail(\"idleConnections\", hikariDataSource.getHikariPoolMXBean().getIdleConnections())\n                            .withDetail(\"totalConnections\", hikariDataSource.getHikariPoolMXBean().getTotalConnections())\n                            .withDetail(\"threadsAwaitingConnection\", hikariDataSource.getHikariPoolMXBean().getThreadsAwaitingConnection());\n                }\n\n                return builder.build();\n\n            } catch (Exception e) {\n                return Health.down()\n                        .withDetail(\"database\", \"Unavailable\")\n                        .withDetail(\"error\", e.getMessage())\n                        .build();\n            }\n        }\n    }\n\n    /**\n     * Custom actuator endpoint for detailed connection pool metrics.\n     */\n    @Component\n    @Endpoint(id = \"connectionpool\")\n    public static class ConnectionPoolEndpoint {\n\n        private final DataSource dataSource;\n\n        public ConnectionPoolEndpoint(DataSource dataSource) {\n            this.dataSource = dataSource;\n        }\n\n        @ReadOperation\n        public Map<String, Object> connectionPoolMetrics() {\n            Map<String, Object> metrics = new HashMap<>();\n\n            if (dataSource instanceof HikariDataSource) {\n                HikariDataSource hikariDataSource = (HikariDataSource) dataSource;\n\n                metrics.put(\"poolName\", hikariDataSource.getPoolName());\n                metrics.put(\"activeConnections\", hikariDataSource.getHikariPoolMXBean().getActiveConnections());\n                metrics.put(\"idleConnections\", hikariDataSource.getHikariPoolMXBean().getIdleConnections());\n                metrics.put(\"totalConnections\", hikariDataSource.getHikariPoolMXBean().getTotalConnections());\n                metrics.put(\"threadsAwaitingConnection\", hikariDataSource.getHikariPoolMXBean().getThreadsAwaitingConnection());\n                metrics.put(\"maximumPoolSize\", hikariDataSource.getMaximumPoolSize());\n                metrics.put(\"minimumIdle\", hikariDataSource.getMinimumIdle());\n                metrics.put(\"connectionTimeout\", hikariDataSource.getConnectionTimeout());\n                metrics.put(\"maxLifetime\", hikariDataSource.getMaxLifetime());\n                metrics.put(\"idleTimeout\", hikariDataSource.getIdleTimeout());\n\n                // Connection usage statistics\n                double utilizationPercentage = (double) hikariDataSource.getHikariPoolMXBean().getActiveConnections()\n                        / hikariDataSource.getMaximumPoolSize() * 100;\n                metrics.put(\"poolUtilizationPercentage\", Math.round(utilizationPercentage * 100.0) / 100.0);\n\n                // Health status\n                boolean isHealthy = hikariDataSource.getHikariPoolMXBean().getActiveConnections() >= 0;\n                metrics.put(\"poolHealthy\", isHealthy);\n\n            } else {\n                metrics.put(\"error\", \"DataSource is not HikariDataSource\");\n            }\n\n            return metrics;\n        }\n    }\n\n    /**\n     * REST controller for testing database connectivity and demonstrating pool usage.\n     */\n    @RestController\n    public static class DatabaseTestController {\n\n        private final JdbcTemplate jdbcTemplate;\n        private final DataSource dataSource;\n\n        public DatabaseTestController(JdbcTemplate jdbcTemplate, DataSource dataSource) {\n            this.jdbcTemplate = jdbcTemplate;\n            this.dataSource = dataSource;\n        }\n\n        /**\n         * Test endpoint to verify database connectivity\n         */\n        @GetMapping(\"/test-db\")\n        public Map<String, Object> testDatabase() {\n            Map<String, Object> result = new HashMap<>();\n\n            try {\n                // Test basic connectivity\n                Integer testResult = jdbcTemplate.queryForObject(\"SELECT 1\", Integer.class);\n                result.put(\"connectionTest\", \"SUCCESS\");\n                result.put(\"testQuery\", \"SELECT 1\");\n                result.put(\"result\", testResult);\n\n                // Get connection pool information\n                if (dataSource instanceof HikariDataSource) {\n                    HikariDataSource hikariDataSource = (HikariDataSource) dataSource;\n                    result.put(\"activeConnections\", hikariDataSource.getHikariPoolMXBean().getActiveConnections());\n                    result.put(\"totalConnections\", hikariDataSource.getHikariPoolMXBean().getTotalConnections());\n                    result.put(\"poolName\", hikariDataSource.getPoolName());\n                }\n\n                result.put(\"timestamp\", System.currentTimeMillis());\n\n            } catch (Exception e) {\n                result.put(\"connectionTest\", \"FAILED\");\n                result.put(\"error\", e.getMessage());\n            }\n\n            return result;\n        }\n\n        /**\n         * Endpoint to simulate database load for testing pool behavior\n         */\n        @GetMapping(\"/load-test\")\n        public Map<String, Object> loadTest() {\n            Map<String, Object> result = new HashMap<>();\n            long startTime = System.currentTimeMillis();\n\n            try {\n                // Simulate multiple database operations\n                for (int i = 0; i < 10; i++) {\n                    jdbcTemplate.queryForObject(\"SELECT \" + (i + 1), Integer.class);\n                }\n\n                long endTime = System.currentTimeMillis();\n                result.put(\"loadTest\", \"SUCCESS\");\n                result.put(\"operations\", 10);\n                result.put(\"executionTimeMs\", endTime - startTime);\n\n                // Pool statistics after load\n                if (dataSource instanceof HikariDataSource) {\n                    HikariDataSource hikariDataSource = (HikariDataSource) dataSource;\n                    result.put(\"activeConnections\", hikariDataSource.getHikariPoolMXBean().getActiveConnections());\n                    result.put(\"totalConnections\", hikariDataSource.getHikariPoolMXBean().getTotalConnections());\n                }\n\n            } catch (Exception e) {\n                result.put(\"loadTest\", \"FAILED\");\n                result.put(\"error\", e.getMessage());\n            }\n\n            return result;\n        }\n\n        /**\n         * Endpoint to get detailed connection pool status\n         */\n        @GetMapping(\"/pool-status\")\n        public Map<String, Object> getPoolStatus() {\n            Map<String, Object> status = new HashMap<>();\n\n            if (dataSource instanceof HikariDataSource) {\n                HikariDataSource hikariDataSource = (HikariDataSource) dataSource;\n\n                status.put(\"poolName\", hikariDataSource.getPoolName());\n                status.put(\"jdbcUrl\", hikariDataSource.getJdbcUrl());\n                status.put(\"maximumPoolSize\", hikariDataSource.getMaximumPoolSize());\n                status.put(\"minimumIdle\", hikariDataSource.getMinimumIdle());\n                status.put(\"activeConnections\", hikariDataSource.getHikariPoolMXBean().getActiveConnections());\n                status.put(\"idleConnections\", hikariDataSource.getHikariPoolMXBean().getIdleConnections());\n                status.put(\"totalConnections\", hikariDataSource.getHikariPoolMXBean().getTotalConnections());\n                status.put(\"threadsAwaitingConnection\", hikariDataSource.getHikariPoolMXBean().getThreadsAwaitingConnection());\n\n                // Configuration details\n                status.put(\"connectionTimeout\", hikariDataSource.getConnectionTimeout());\n                status.put(\"maxLifetime\", hikariDataSource.getMaxLifetime());\n                status.put(\"idleTimeout\", hikariDataSource.getIdleTimeout());\n                status.put(\"leakDetectionThreshold\", hikariDataSource.getLeakDetectionThreshold());\n\n                // Calculate pool efficiency metrics\n                double utilization = (double) hikariDataSource.getHikariPoolMXBean().getActiveConnections()\n                        / hikariDataSource.getMaximumPoolSize();\n                status.put(\"poolUtilization\", Math.round(utilization * 10000.0) / 100.0 + \"%\");\n\n                boolean isOptimal = hikariDataSource.getHikariPoolMXBean().getThreadsAwaitingConnection() == 0\n                        && hikariDataSource.getHikariPoolMXBean().getActiveConnections() > 0;\n                status.put(\"performanceOptimal\", isOptimal);\n\n            } else {\n                status.put(\"error\", \"DataSource is not HikariDataSource\");\n            }\n\n            status.put(\"timestamp\", System.currentTimeMillis());\n            return status;\n        }\n    }\n}\n\n```",
  "test": "```java\n\npackage com.example.connectionpool;\n\nimport com.example.connectionpool.DatabaseConnectionPoolApplication.ConnectionPoolEndpoint;\nimport com.example.connectionpool.DatabaseConnectionPoolApplication.DatabaseHealthIndicator;\nimport com.example.connectionpool.DatabaseConnectionPoolApplication.HikariProperties;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.zaxxer.hikari.HikariDataSource;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.health.Health;\nimport org.springframework.boot.actuate.health.Status;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.boot.test.web.server.LocalServerPort;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.test.context.ActiveProfiles;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertInstanceOf;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.when;\n\n/**\n * Comprehensive test suite for DatabaseConnectionPoolApplication.\n * Tests all aspects of HikariCP configuration, database connectivity, health monitoring,\n * REST endpoints, actuator integration, and performance characteristics.\n */\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@ActiveProfiles(\"test\")\n@DisplayName(\"Database Connection Pool Application Tests\")\nclass DatabaseConnectionPoolApplicationTest {\n\n    @LocalServerPort\n    private int port;\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Autowired\n    private ObjectMapper objectMapper;\n\n    @Autowired\n    private DataSource dataSource;\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Autowired\n    private DatabaseHealthIndicator healthIndicator;\n\n    @Autowired\n    private ConnectionPoolEndpoint connectionPoolEndpoint;\n\n    @Autowired\n    private HikariProperties hikariProperties;\n\n    @Mock\n    private JdbcTemplate mockJdbcTemplate;\n\n    @Mock\n    private DataSource mockDataSource;\n\n    @BeforeEach\n    void setUp() {\n        MockitoAnnotations.openMocks(this);\n    }\n\n    // ========================================\n    // HIKARI PROPERTIES TESTS\n    // ========================================\n\n    @Nested\n    @DisplayName(\"HikariCP Properties Tests\")\n    class HikariPropertiesTests {\n\n        @Test\n        @DisplayName(\"Should have correct default pool size settings\")\n        void testDefaultPoolSizeSettings() {\n            HikariProperties properties = new HikariProperties();\n            assertEquals(20, properties.getMaximumPoolSize(), \n                \"Default maximum pool size should be 20\");\n            assertEquals(5, properties.getMinimumIdle(), \n                \"Default minimum idle should be 5\");\n        }\n\n        @Test\n        @DisplayName(\"Should have correct default timeout settings\")\n        void testDefaultTimeoutSettings() {\n            HikariProperties properties = new HikariProperties();\n            assertEquals(20000L, properties.getConnectionTimeout(), \n                \"Default connection timeout should be 20000ms\");\n            assertEquals(1200000L, properties.getMaxLifetime(), \n                \"Default max lifetime should be 1200000ms (20 minutes)\");\n            assertEquals(300000L, properties.getIdleTimeout(), \n                \"Default idle timeout should be 300000ms (5 minutes)\");\n            assertEquals(5000L, properties.getValidationTimeout(), \n                \"Default validation timeout should be 5000ms\");\n        }\n\n        @Test\n        @DisplayName(\"Should have correct default reliability settings\")\n        void testDefaultReliabilitySettings() {\n            HikariProperties properties = new HikariProperties();\n            assertEquals(60000L, properties.getLeakDetectionThreshold(),\n                \"Default leak detection threshold should be 300000ms (1 minute)\");\n            assertTrue(properties.isAutoCommit(), \n                \"Default auto commit should be true\");\n            assertEquals(\"SELECT 1\", properties.getConnectionTestQuery(), \n                \"Default connection test query should be 'SELECT 1'\");\n        }\n\n        @Test\n        @DisplayName(\"Should allow setting and getting all properties\")\n        void testPropertySettersGetters() {\n            HikariProperties properties = new HikariProperties();\n            \n            // Test pool size properties\n            properties.setMaximumPoolSize(50);\n            properties.setMinimumIdle(10);\n            assertEquals(50, properties.getMaximumPoolSize());\n            assertEquals(10, properties.getMinimumIdle());\n            \n            // Test timeout properties\n            properties.setConnectionTimeout(30000L);\n            properties.setMaxLifetime(1800000L);\n            properties.setIdleTimeout(3000000L);\n            properties.setValidationTimeout(10000L);\n            assertEquals(30000L, properties.getConnectionTimeout());\n            assertEquals(1800000L, properties.getMaxLifetime());\n            assertEquals(3000000L, properties.getIdleTimeout());\n            assertEquals(10000L, properties.getValidationTimeout());\n            \n            // Test reliability properties\n            properties.setLeakDetectionThreshold(120000L);\n            properties.setAutoCommit(false);\n            properties.setConnectionTestQuery(\"SELECT 1 FROM DUAL\");\n            assertEquals(120000L, properties.getLeakDetectionThreshold());\n            assertFalse(properties.isAutoCommit());\n            assertEquals(\"SELECT 1 FROM DUAL\", properties.getConnectionTestQuery());\n            \n            // Test monitoring properties\n            properties.setRegisterMbeans(false);\n            properties.setPoolName(\"TestPool\");\n            assertFalse(properties.isRegisterMbeans());\n            assertEquals(\"TestPool\", properties.getPoolName());\n            \n            // Test database properties\n            properties.setJdbcUrl(\"jdbc:mysql://localhost:3306/testdb\");\n            properties.setUsername(\"testuser\");\n            properties.setPassword(\"testpassword\");\n            properties.setDriverClassName(\"com.mysql.cj.jdbc.Driver\");\n            assertEquals(\"jdbc:mysql://localhost:3306/testdb\", properties.getJdbcUrl());\n            assertEquals(\"testuser\", properties.getUsername());\n            assertEquals(\"testpassword\", properties.getPassword());\n            assertEquals(\"com.mysql.cj.jdbc.Driver\", properties.getDriverClassName());\n        }\n    }\n\n    // ========================================\n    // DATABASE CONFIGURATION TESTS\n    // ========================================\n\n    @Nested\n    @DisplayName(\"Database Configuration Tests\")\n    class DatabaseConfigurationTests {\n\n        @Test\n        @DisplayName(\"Should create HikariDataSource bean\")\n        void testHikariDataSourceCreation() {\n            assertNotNull(dataSource, \"DataSource should not be null\");\n            assertInstanceOf(HikariDataSource.class, dataSource, \n                \"DataSource should be instance of HikariDataSource\");\n        }\n\n        @Test\n        @DisplayName(\"Should configure HikariDataSource with correct properties\")\n        void testHikariDataSourceConfiguration() {\n            HikariDataSource hikariDataSource = (HikariDataSource) dataSource;\n            \n            // Test pool configuration matches test properties\n            assertEquals(20, hikariDataSource.getMaximumPoolSize(),\n                \"Maximum pool size should match test configuration\");\n            assertEquals(5, hikariDataSource.getMinimumIdle(),\n                \"Minimum idle should match test configuration\");\n            \n            // Test timeout configuration\n            assertEquals(20000L, hikariDataSource.getConnectionTimeout(),\n                \"Connection timeout should match test configuration\");\n            assertEquals(1200000L, hikariDataSource.getMaxLifetime(),\n                \"Max lifetime should match test configuration\");\n            assertEquals(300000L, hikariDataSource.getIdleTimeout(),\n                \"Idle timeout should match test configuration\");\n            \n            // Test monitoring settings\n            assertEquals(\"HikariCP-Primary\", hikariDataSource.getPoolName(),\n                \"Pool name should match test configuration\");\n        }\n\n        @Test\n        @DisplayName(\"Should establish database connection successfully\")\n        void testDatabaseConnection() throws SQLException {\n            try (Connection connection = dataSource.getConnection()) {\n                assertNotNull(connection, \"Connection should not be null\");\n                assertFalse(connection.isClosed(), \"Connection should be open\");\n                assertTrue(connection.isValid(5), \"Connection should be valid\");\n            }\n        }\n\n        @Test\n        @DisplayName(\"Should execute database operations successfully\")\n        void testDatabaseOperations() {\n            // Test simple query\n            Integer result = jdbcTemplate.queryForObject(\"SELECT 1\", Integer.class);\n            assertNotNull(result, \"Query result should not be null\");\n            assertEquals(1, result, \"Query should return 1\");\n            \n            // Test DDL and DML operations\n            jdbcTemplate.execute(\"CREATE TABLE IF NOT EXISTS test_table (id INT PRIMARY KEY, name VARCHAR(50))\");\n            \n            int rowsAffected = jdbcTemplate.update(\"INSERT INTO test_table (id, name) VALUES (?, ?)\", 1, \"Test\");\n            assertEquals(1, rowsAffected, \"Should insert one row\");\n            \n            String name = jdbcTemplate.queryForObject(\"SELECT name FROM test_table WHERE id = ?\", \n                String.class, 1);\n            assertEquals(\"Test\", name, \"Should retrieve correct name\");\n            \n            jdbcTemplate.execute(\"DROP TABLE test_table\");\n        }\n\n        @Test\n        @DisplayName(\"Should handle multiple concurrent connections\")\n        void testMultipleConnections() throws SQLException {\n            Connection[] connections = new Connection[3];\n            \n            try {\n                for (int i = 0; i < connections.length; i++) {\n                    connections[i] = dataSource.getConnection();\n                    assertNotNull(connections[i], \"Connection \" + i + \" should not be null\");\n                    assertTrue(connections[i].isValid(5), \"Connection \" + i + \" should be valid\");\n                }\n            } finally {\n                for (Connection connection : connections) {\n                    if (connection != null && !connection.isClosed()) {\n                        connection.close();\n                    }\n                }\n            }\n        }\n    }\n\n    // ========================================\n    // HEALTH INDICATOR TESTS\n    // ========================================\n\n    @Nested\n    @DisplayName(\"Database Health Indicator Tests\")\n    class HealthIndicatorTests {\n\n        @Test\n        @DisplayName(\"Should return UP status when database is healthy\")\n        void testHealthyDatabase() {\n            Health health = healthIndicator.health();\n            \n            assertNotNull(health, \"Health should not be null\");\n            assertEquals(Status.UP, health.getStatus(), \"Health status should be UP\");\n            \n            assertEquals(\"Available\", health.getDetails().get(\"database\"), \n                \"Database should be marked as Available\");\n            assertEquals(\"SELECT 1\", health.getDetails().get(\"validationQuery\"), \n                \"Validation query should be included in details\");\n        }\n\n        @Test\n        @DisplayName(\"Should include HikariCP metrics in health details\")\n        void testHikariMetricsInHealth() {\n            Health health = healthIndicator.health();\n            \n            assertEquals(Status.UP, health.getStatus(), \"Health status should be UP\");\n            \n            assertTrue(health.getDetails().containsKey(\"poolName\"), \n                \"Health details should include pool name\");\n            assertTrue(health.getDetails().containsKey(\"activeConnections\"), \n                \"Health details should include active connections\");\n            assertTrue(health.getDetails().containsKey(\"totalConnections\"), \n                \"Health details should include total connections\");\n        }\n\n        @Test\n        @DisplayName(\"Should return DOWN status when database query fails\")\n        void testUnhealthyDatabase() {\n            when(mockJdbcTemplate.queryForObject(\"SELECT 1\", Integer.class))\n                .thenThrow(new RuntimeException(\"Database connection failed\"));\n            \n            DatabaseHealthIndicator unhealthyIndicator = new DatabaseHealthIndicator(mockDataSource, mockJdbcTemplate);\n            Health health = unhealthyIndicator.health();\n            \n            assertNotNull(health, \"Health should not be null\");\n            assertEquals(Status.DOWN, health.getStatus(), \"Health status should be DOWN\");\n            assertEquals(\"Unavailable\", health.getDetails().get(\"database\"), \n                \"Database should be marked as Unavailable\");\n            assertTrue(health.getDetails().containsKey(\"error\"), \n                \"Health details should include error information\");\n        }\n    }\n\n    // ========================================\n    // REST CONTROLLER TESTS\n    // ========================================\n\n    @Nested\n    @DisplayName(\"REST Controller Tests\")\n    class RestControllerTests {\n\n        @Test\n        @DisplayName(\"Should test database connectivity successfully\")\n        void testDatabaseConnectivity() throws Exception {\n            ResponseEntity<Map> response = restTemplate.getForEntity(\n                \"http://localhost:\" + port + \"/test-db\", Map.class);\n            \n            assertEquals(200, response.getStatusCodeValue());\n            assertNotNull(response.getBody());\n            \n            Map<String, Object> body = response.getBody();\n            assertEquals(\"SUCCESS\", body.get(\"connectionTest\"));\n            assertEquals(\"SELECT 1\", body.get(\"testQuery\"));\n            assertEquals(1, body.get(\"result\"));\n            assertTrue(body.containsKey(\"timestamp\"));\n            assertTrue(body.containsKey(\"activeConnections\"));\n            assertTrue(body.containsKey(\"poolName\"));\n        }\n\n        @Test\n        @DisplayName(\"Should perform load test successfully\")\n        void testLoadTest() throws Exception {\n            ResponseEntity<Map> response = restTemplate.getForEntity(\n                \"http://localhost:\" + port + \"/load-test\", Map.class);\n            \n            assertEquals(200, response.getStatusCodeValue());\n            assertNotNull(response.getBody());\n            \n            Map<String, Object> body = response.getBody();\n            assertEquals(\"SUCCESS\", body.get(\"loadTest\"));\n            assertEquals(10, body.get(\"operations\"));\n            assertTrue(body.containsKey(\"executionTimeMs\"));\n            assertTrue((Integer) body.get(\"executionTimeMs\") >= 0);\n        }\n\n        @Test\n        @DisplayName(\"Should return detailed pool status\")\n        void testPoolStatus() throws Exception {\n            ResponseEntity<Map> response = restTemplate.getForEntity(\n                \"http://localhost:\" + port + \"/pool-status\", Map.class);\n            \n            assertEquals(200, response.getStatusCodeValue());\n            assertNotNull(response.getBody());\n            \n            Map<String, Object> body = response.getBody();\n            assertTrue(body.containsKey(\"poolName\"));\n            assertTrue(body.containsKey(\"maximumPoolSize\"));\n            assertTrue(body.containsKey(\"activeConnections\"));\n            assertTrue(body.containsKey(\"poolUtilization\"));\n            assertTrue(body.containsKey(\"timestamp\"));\n        }\n\n        @Test\n        @DisplayName(\"Should handle concurrent requests\")\n        void testConcurrentRequests() throws InterruptedException {\n            final int threadCount = 3;\n            final Thread[] threads = new Thread[threadCount];\n            final Exception[] exceptions = new Exception[threadCount];\n            \n            for (int i = 0; i < threadCount; i++) {\n                final int index = i;\n                threads[i] = new Thread(() -> {\n                    try {\n                        ResponseEntity<Map> response = restTemplate.getForEntity(\n                            \"http://localhost:\" + port + \"/test-db\", Map.class);\n                        assertEquals(200, response.getStatusCodeValue());\n                        assertEquals(\"SUCCESS\", response.getBody().get(\"connectionTest\"));\n                    } catch (Exception e) {\n                        exceptions[index] = e;\n                    }\n                });\n            }\n            \n            for (Thread thread : threads) {\n                thread.start();\n            }\n            \n            for (Thread thread : threads) {\n                thread.join();\n            }\n            \n            for (int i = 0; i < threadCount; i++) {\n                assertNull(exceptions[i], \"Thread \" + i + \" should not have thrown an exception\");\n            }\n        }\n    }\n\n    // ========================================\n    // ACTUATOR ENDPOINT TESTS\n    // ========================================\n\n    @Nested\n    @DisplayName(\"Actuator Endpoint Tests\")\n    class ActuatorEndpointTests {\n\n        @Test\n        @DisplayName(\"Should expose connection pool endpoint\")\n        void testConnectionPoolEndpointAvailable() throws Exception {\n            ResponseEntity<Map> response = restTemplate.getForEntity(\n                \"http://localhost:\" + port + \"/actuator/connectionpool\", Map.class);\n            \n            assertEquals(200, response.getStatusCodeValue());\n            assertNotNull(response.getBody());\n        }\n\n        @Test\n        @DisplayName(\"Should return comprehensive connection pool metrics\")\n        void testConnectionPoolMetrics() throws Exception {\n            ResponseEntity<Map> response = restTemplate.getForEntity(\n                \"http://localhost:\" + port + \"/actuator/connectionpool\", Map.class);\n            \n            assertEquals(200, response.getStatusCodeValue());\n            assertNotNull(response.getBody());\n            \n            Map<String, Object> metrics = response.getBody();\n            assertEquals(\"HikariCP-Primary\", metrics.get(\"poolName\"));\n            assertTrue((Integer) metrics.get(\"activeConnections\") >= 0);\n            assertTrue((Integer) metrics.get(\"maximumPoolSize\") > 0);\n            assertTrue((Double) metrics.get(\"poolUtilizationPercentage\") >= 0.0);\n            assertTrue((Boolean) metrics.get(\"poolHealthy\"));\n        }\n\n        @Test\n        @DisplayName(\"Should include health endpoint in actuator\")\n        void testHealthEndpointAvailable() throws Exception {\n            ResponseEntity<Map> response = restTemplate.getForEntity(\n                \"http://localhost:\" + port + \"/actuator/health\", Map.class);\n            \n            assertEquals(200, response.getStatusCodeValue());\n            assertNotNull(response.getBody());\n            assertEquals(\"UP\", response.getBody().get(\"status\"));\n        }\n\n        @Test\n        @DisplayName(\"Should include database health in health endpoint\")\n        void testDatabaseHealthInHealthEndpoint() throws Exception {\n            ResponseEntity<Map> response = restTemplate.getForEntity(\n                \"http://localhost:\" + port + \"/actuator/health\", Map.class);\n            \n            assertEquals(200, response.getStatusCodeValue());\n            assertNotNull(response.getBody());\n            \n            Map<String, Object> health = response.getBody();\n            \n            // Debug the actual response structure\n            System.out.println(\"Health response: \" + health);\n            \n            // Check if components exist\n            if (health.containsKey(\"components\")) {\n                @SuppressWarnings(\"unchecked\")\n                Map<String, Object> components = (Map<String, Object>) health.get(\"components\");\n                assertNotNull(components, \"Components should not be null\");\n                \n                // Check if database component exists\n                if (components.containsKey(\"database\")) {\n                    @SuppressWarnings(\"unchecked\")\n                    Map<String, Object> database = (Map<String, Object>) components.get(\"database\");\n                    assertNotNull(database, \"Database component should not be null\");\n                    assertEquals(\"UP\", database.get(\"status\"));\n                } else {\n                    // If database component doesn't exist, just verify overall health is UP\n                    assertEquals(\"UP\", health.get(\"status\"));\n                    System.out.println(\"Database component not found in health response, but overall status is UP\");\n                }\n            } else {\n                // If no components, just verify overall health is UP\n                assertEquals(\"UP\", health.get(\"status\"));\n                System.out.println(\"No components found in health response, but overall status is UP\");\n            }\n        }\n\n        @Test\n        @DisplayName(\"Should test direct endpoint method call\")\n        void testDirectEndpointCall() {\n            Map<String, Object> metrics = connectionPoolEndpoint.connectionPoolMetrics();\n            \n            assertNotNull(metrics, \"Metrics should not be null\");\n            assertFalse(metrics.isEmpty(), \"Metrics should not be empty\");\n            assertTrue(metrics.containsKey(\"poolName\"), \"Should contain pool name\");\n            assertTrue(metrics.containsKey(\"activeConnections\"), \"Should contain active connections\");\n            assertFalse(metrics.containsKey(\"error\"), \"Should not contain error key\");\n        }\n    }\n\n    // ========================================\n    // PERFORMANCE TESTS\n    // ========================================\n\n    @Nested\n    @DisplayName(\"Performance Tests\")\n    class PerformanceTests {\n\n        @Test\n        @DisplayName(\"Should handle concurrent connection requests efficiently\")\n        @Timeout(20)\n        void testConcurrentConnectionRequests() throws InterruptedException {\n            final int threadCount = 5;\n            final int operationsPerThread = 10;\n            final CountDownLatch startLatch = new CountDownLatch(1);\n            final CountDownLatch completionLatch = new CountDownLatch(threadCount);\n            final AtomicInteger successCount = new AtomicInteger(0);\n            final AtomicInteger errorCount = new AtomicInteger(0);\n\n            ExecutorService executor = Executors.newFixedThreadPool(threadCount);\n\n            for (int i = 0; i < threadCount; i++) {\n                executor.submit(() -> {\n                    try {\n                        startLatch.await();\n                        \n                        for (int j = 0; j < operationsPerThread; j++) {\n                            try (Connection connection = dataSource.getConnection()) {\n                                try (var statement = connection.createStatement()) {\n                                    var resultSet = statement.executeQuery(\"SELECT 1\");\n                                    if (resultSet.next()) {\n                                        successCount.incrementAndGet();\n                                    }\n                                }\n                            } catch (SQLException e) {\n                                errorCount.incrementAndGet();\n                            }\n                        }\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                    } finally {\n                        completionLatch.countDown();\n                    }\n                });\n            }\n\n            long testStartTime = System.currentTimeMillis();\n            startLatch.countDown();\n            completionLatch.await();\n            long testEndTime = System.currentTimeMillis();\n\n            executor.shutdown();\n\n            int expectedSuccessCount = threadCount * operationsPerThread;\n            assertEquals(expectedSuccessCount, successCount.get(), \n                \"All operations should succeed\");\n            assertEquals(0, errorCount.get(), \"No errors should occur\");\n\n            long totalExecutionTime = testEndTime - testStartTime;\n            assertTrue(totalExecutionTime < 15000, \n                \"Test should complete within 15 seconds\");\n\n            System.out.println(\"Concurrent Test Results:\");\n            System.out.println(\"Total operations: \" + expectedSuccessCount);\n            System.out.println(\"Execution time: \" + totalExecutionTime + \"ms\");\n            System.out.println(\"Operations/sec: \" + (expectedSuccessCount * 1000.0 / totalExecutionTime));\n        }\n\n        @Test\n        @DisplayName(\"Should handle connection pool exhaustion gracefully\")\n        @Timeout(15)\n        void testConnectionPoolExhaustion() throws InterruptedException {\n            HikariDataSource hikariDataSource = (HikariDataSource) dataSource;\n            int maxPoolSize = hikariDataSource.getMaximumPoolSize();\n            \n            List<Connection> connections = new ArrayList<>();\n            \n            try {\n                // Try to get connections up to the pool limit\n                for (int i = 0; i < maxPoolSize; i++) {\n                    try {\n                        Connection connection = dataSource.getConnection();\n                        connections.add(connection);\n                    } catch (SQLException e) {\n                        break;\n                    }\n                }\n                \n                // Verify pool metrics\n                int activeConnections = hikariDataSource.getHikariPoolMXBean().getActiveConnections();\n                int totalConnections = hikariDataSource.getHikariPoolMXBean().getTotalConnections();\n                \n                assertTrue(activeConnections <= maxPoolSize, \n                    \"Active connections should not exceed max pool size\");\n                assertTrue(totalConnections <= maxPoolSize, \n                    \"Total connections should not exceed max pool size\");\n                \n            } finally {\n                // Clean up all connections\n                for (Connection connection : connections) {\n                    try {\n                        if (connection != null && !connection.isClosed()) {\n                            connection.close();\n                        }\n                    } catch (SQLException e) {\n                        // Ignore cleanup errors\n                    }\n                }\n            }\n            \n            // Wait for connections to be returned to pool\n            Thread.sleep(1000);\n            \n            // Verify pool recovered\n            assertTrue(hikariDataSource.getHikariPoolMXBean().getIdleConnections() >= 0, \n                \"Pool should have recovered after cleanup\");\n        }\n\n        @Test\n        @DisplayName(\"Should demonstrate connection reuse efficiency\")\n        void testConnectionReuseEfficiency() throws SQLException {\n            HikariDataSource hikariDataSource = (HikariDataSource) dataSource;\n            \n            int initialTotalConnections = hikariDataSource.getHikariPoolMXBean().getTotalConnections();\n            \n            // Perform multiple operations\n            final int operationCount = 50;\n            for (int i = 0; i < operationCount; i++) {\n                try (Connection connection = dataSource.getConnection()) {\n                    try (var statement = connection.createStatement()) {\n                        var resultSet = statement.executeQuery(\"SELECT \" + (i + 1));\n                        assertTrue(resultSet.next(), \"Query should return a result\");\n                        assertEquals(i + 1, resultSet.getInt(1), \"Query should return correct value\");\n                    }\n                }\n            }\n            \n            int finalTotalConnections = hikariDataSource.getHikariPoolMXBean().getTotalConnections();\n            \n            // Verify connection reuse (pool shouldn't grow significantly)\n            assertTrue(finalTotalConnections <= initialTotalConnections + 3, \n                \"Connection pool should not grow significantly with reuse\");\n            \n            assertTrue(hikariDataSource.getHikariPoolMXBean().getActiveConnections() >= 0, \n                \"Active connections should be non-negative\");\n        }\n\n        @Test\n        @DisplayName(\"Should handle rapid connection cycling\")\n        @Timeout(10)\n        void testRapidConnectionCycling() {\n            final int cycleCount = 100;\n            final AtomicInteger successCount = new AtomicInteger(0);\n            final AtomicInteger errorCount = new AtomicInteger(0);\n            \n            long startTime = System.currentTimeMillis();\n            \n            for (int i = 0; i < cycleCount; i++) {\n                try (Connection connection = dataSource.getConnection()) {\n                    assertTrue(connection.isValid(1), \"Connection should be valid\");\n                    successCount.incrementAndGet();\n                } catch (SQLException e) {\n                    errorCount.incrementAndGet();\n                }\n            }\n            \n            long endTime = System.currentTimeMillis();\n            long duration = endTime - startTime;\n            \n            assertEquals(cycleCount, successCount.get(), \"All cycles should succeed\");\n            assertEquals(0, errorCount.get(), \"No errors should occur\");\n            assertTrue(duration < 8000, \"Rapid cycling should complete within 8 seconds\");\n            \n            double cyclesPerSecond = (cycleCount * 1000.0) / duration;\n            assertTrue(cyclesPerSecond > 10, \"Should achieve reasonable cycling rate\");\n            \n            System.out.println(\"Rapid Cycling Results:\");\n            System.out.println(\"Cycles: \" + cycleCount);\n            System.out.println(\"Duration: \" + duration + \"ms\");\n            System.out.println(\"Cycles/sec: \" + cyclesPerSecond);\n        }\n\n        @Test\n        @DisplayName(\"Should maintain pool health under mixed workload\")\n        @Timeout(25)\n        void testMixedWorkload() throws InterruptedException {\n            final int duration = 10; // seconds\n            final CountDownLatch completionLatch = new CountDownLatch(2);\n            final AtomicInteger shortOperations = new AtomicInteger(0);\n            final AtomicInteger longOperations = new AtomicInteger(0);\n            final AtomicInteger totalErrors = new AtomicInteger(0);\n\n            ExecutorService executor = Executors.newFixedThreadPool(2);\n            long testEndTime = System.currentTimeMillis() + (duration * 1000);\n\n            // Short operations thread\n            executor.submit(() -> {\n                try {\n                    while (System.currentTimeMillis() < testEndTime) {\n                        try {\n                            Integer result = jdbcTemplate.queryForObject(\"SELECT 1\", Integer.class);\n                            if (result != null) {\n                                shortOperations.incrementAndGet();\n                            }\n                            Thread.sleep(50);\n                        } catch (Exception e) {\n                            totalErrors.incrementAndGet();\n                        }\n                    }\n                } finally {\n                    completionLatch.countDown();\n                }\n            });\n\n            // Long operations thread\n            executor.submit(() -> {\n                try {\n                    while (System.currentTimeMillis() < testEndTime) {\n                        try (Connection connection = dataSource.getConnection()) {\n                            Thread.sleep(100); // Simulate longer operation\n                            try (var statement = connection.createStatement()) {\n                                var resultSet = statement.executeQuery(\"SELECT 1\");\n                                if (resultSet.next()) {\n                                    longOperations.incrementAndGet();\n                                }\n                            }\n                        } catch (Exception e) {\n                            totalErrors.incrementAndGet();\n                        }\n                    }\n                } finally {\n                    completionLatch.countDown();\n                }\n            });\n\n            completionLatch.await();\n            executor.shutdown();\n\n            assertTrue(shortOperations.get() > 0, \"Should perform short operations\");\n            assertTrue(longOperations.get() > 0, \"Should perform long operations\");\n            \n            int totalOperations = shortOperations.get() + longOperations.get();\n            assertTrue(totalErrors.get() < totalOperations * 0.05, \n                \"Error rate should be less than 5%\");\n\n            HikariDataSource hikariDataSource = (HikariDataSource) dataSource;\n            assertTrue(hikariDataSource.getHikariPoolMXBean().getActiveConnections() >= 0, \n                \"Pool should be healthy after mixed workload\");\n\n            System.out.println(\"Mixed Workload Results:\");\n            System.out.println(\"Short ops: \" + shortOperations.get());\n            System.out.println(\"Long ops: \" + longOperations.get());\n            System.out.println(\"Errors: \" + totalErrors.get());\n        }\n    }\n\n    // ========================================\n    // INTEGRATION TESTS\n    // ========================================\n\n    @Nested\n    @DisplayName(\"Integration Tests\")\n    class IntegrationTests {\n\n        @Test\n        @DisplayName(\"Should validate complete application integration\")\n        void testCompleteIntegration() throws Exception {\n            // Test that all components work together\n            \n            // 1. Test database connectivity\n            Integer dbResult = jdbcTemplate.queryForObject(\"SELECT 1\", Integer.class);\n            assertEquals(1, dbResult, \"Database should be accessible\");\n            \n            // 2. Test health indicator\n            Health health = healthIndicator.health();\n            assertEquals(Status.UP, health.getStatus(), \"Health should be UP\");\n            \n            // 3. Test REST endpoints\n            ResponseEntity<Map> testDbResponse = restTemplate.getForEntity(\n                \"http://localhost:\" + port + \"/test-db\", Map.class);\n            assertEquals(200, testDbResponse.getStatusCodeValue());\n            assertEquals(\"SUCCESS\", testDbResponse.getBody().get(\"connectionTest\"));\n            \n            // 4. Test actuator endpoints\n            ResponseEntity<Map> healthResponse = restTemplate.getForEntity(\n                \"http://localhost:\" + port + \"/actuator/health\", Map.class);\n            assertEquals(200, healthResponse.getStatusCodeValue());\n            assertEquals(\"UP\", healthResponse.getBody().get(\"status\"));\n            \n            ResponseEntity<Map> poolResponse = restTemplate.getForEntity(\n                \"http://localhost:\" + port + \"/actuator/connectionpool\", Map.class);\n            assertEquals(200, poolResponse.getStatusCodeValue());\n            assertTrue((Boolean) poolResponse.getBody().get(\"poolHealthy\"));\n            \n            // 5. Test connection pool metrics\n            Map<String, Object> metrics = connectionPoolEndpoint.connectionPoolMetrics();\n            assertNotNull(metrics, \"Metrics should be available\");\n            assertTrue((Boolean) metrics.get(\"poolHealthy\"), \"Pool should be healthy\");\n            \n            System.out.println(\"Integration Test Results:\");\n            System.out.println(\"Database connectivity: PASSED\");\n            System.out.println(\"Health indicator: PASSED\");\n            System.out.println(\"REST endpoints: PASSED\");\n            System.out.println(\"Actuator endpoints: PASSED\");\n            System.out.println(\"Connection pool metrics: PASSED\");\n            System.out.println(\"All components integrated successfully!\");\n        }\n\n        @Test\n        @DisplayName(\"Should validate configuration consistency across components\")\n        void testConfigurationConsistency() {\n            HikariDataSource hikariDataSource = (HikariDataSource) dataSource;\n            \n            // Verify configuration consistency between components\n            assertEquals(\"HikariCP-Primary\", hikariDataSource.getPoolName(),\n                \"Pool name should be consistent\");\n            assertEquals(20, hikariDataSource.getMaximumPoolSize(),\n                \"Max pool size should match test configuration\");\n            assertEquals(5, hikariDataSource.getMinimumIdle(),\n                \"Min idle should match test configuration\");\n            \n            // Verify health indicator reflects actual configuration\n            Health health = healthIndicator.health();\n            assertEquals(\"HikariCP-Primary\", health.getDetails().get(\"poolName\"),\n                \"Health indicator should show correct pool name\");\n            \n            // Verify actuator endpoint reflects actual configuration\n            Map<String, Object> metrics = connectionPoolEndpoint.connectionPoolMetrics();\n            assertEquals(\"HikariCP-Primary\", metrics.get(\"poolName\"),\n                \"Actuator endpoint should show correct pool name\");\n            assertEquals(20, metrics.get(\"maximumPoolSize\"),\n                \"Actuator endpoint should show correct max pool size\");\n        }\n    }\n}\n\n\n```",
  "dependencies": "```xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.7.0</version>\n        <relativePath/>\n    </parent>\n\n    <groupId>com.example</groupId>\n    <artifactId>jwt-spring-security</artifactId>\n    <version>1.0.0</version>\n    <name>jwt-spring-security</name>\n    <description>Spring Boot application with JWT authentication</description>\n\n    <properties>\n        <java.version>11</java.version>\n    </properties>\n\n    <dependencies>\n        <!-- Spring Boot Starter Web -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <!-- Spring Boot Starter Security -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n\n        <!-- JWT Library -->\n        <dependency>\n            <groupId>io.jsonwebtoken</groupId>\n            <artifactId>jjwt-api</artifactId>\n            <version>0.11.5</version>\n        </dependency>\n        <dependency>\n            <groupId>io.jsonwebtoken</groupId>\n            <artifactId>jjwt-impl</artifactId>\n            <version>0.11.5</version>\n            <scope>runtime</scope>\n        </dependency>\n        <dependency>\n            <groupId>io.jsonwebtoken</groupId>\n            <artifactId>jjwt-jackson</artifactId>\n            <version>0.11.5</version>\n            <scope>runtime</scope>\n        </dependency>\n\n        <!-- Spring Boot Starter Test -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n\n        <!-- Spring Security Test -->\n        <dependency>\n            <groupId>org.springframework.security</groupId>\n            <artifactId>spring-security-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n\n\n```",
  "bash": "```bash\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <!-- Project Information -->\n    <groupId>com.example</groupId>\n    <artifactId>database-connection-pool</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n    \n    <name>Database Connection Pool Configuration</name>\n    <description>High-performance HikariCP database connection pool configuration with Spring Boot</description>\n    \n    <!-- Properties -->\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <spring-boot.version>2.7.14</spring-boot.version>\n        <java.version>11</java.version>\n    </properties>\n\n    <!-- Spring Boot Parent -->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.7.14</version>\n        <relativePath/>\n    </parent>\n\n    <!-- Dependencies -->\n    <dependencies>\n        <!-- Spring Boot Web Starter -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <!-- Spring Boot JDBC Starter (includes HikariCP) -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-jdbc</artifactId>\n        </dependency>\n\n        <!-- Spring Boot Actuator for monitoring -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\n        <!-- HikariCP (explicitly included, though it's default in Spring Boot 2+) -->\n        <dependency>\n            <groupId>com.zaxxer</groupId>\n            <artifactId>HikariCP</artifactId>\n        </dependency>\n\n        <!-- H2 Database for demonstration -->\n        <dependency>\n            <groupId>com.h2database</groupId>\n            <artifactId>h2</artifactId>\n            <scope>runtime</scope>\n        </dependency>\n\n        <!-- MySQL Connector (optional, uncomment if using MySQL) -->\n        <!--\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <scope>runtime</scope>\n        </dependency>\n        -->\n\n        <!-- PostgreSQL Driver (optional, uncomment if using PostgreSQL) -->\n        <!--\n        <dependency>\n            <groupId>org.postgresql</groupId>\n            <artifactId>postgresql</artifactId>\n            <scope>runtime</scope>\n        </dependency>\n        -->\n\n        <!-- Oracle JDBC Driver (optional, uncomment if using Oracle) -->\n        <!--\n        <dependency>\n            <groupId>com.oracle.database.jdbc</groupId>\n            <artifactId>ojdbc8</artifactId>\n            <scope>runtime</scope>\n        </dependency>\n        -->\n\n        <!-- SQL Server JDBC Driver (optional, uncomment if using SQL Server) -->\n        <!--\n        <dependency>\n            <groupId>com.microsoft.sqlserver</groupId>\n            <artifactId>mssql-jdbc</artifactId>\n            <scope>runtime</scope>\n        </dependency>\n        -->\n\n        <!-- Spring Boot Configuration Processor -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n            <optional>true</optional>\n        </dependency>\n\n        <!-- Test Dependencies -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n\n        <!-- JUnit 5 for testing -->\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter</artifactId>\n            <scope>test</scope>\n        </dependency>\n\n        <!-- Testcontainers for integration testing (optional) -->\n        <!--\n        <dependency>\n            <groupId>org.testcontainers</groupId>\n            <artifactId>junit-jupiter</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.testcontainers</groupId>\n            <artifactId>mysql</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.testcontainers</groupId>\n            <artifactId>postgresql</artifactId>\n            <scope>test</scope>\n        </dependency>\n        -->\n    </dependencies>\n\n    <!-- Build Configuration -->\n    <build>\n        <plugins>\n            <!-- Spring Boot Maven Plugin -->\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                    <excludes>\n                        <exclude>\n                            <groupId>org.springframework.boot</groupId>\n                            <artifactId>spring-boot-configuration-processor</artifactId>\n                        </exclude>\n                    </excludes>\n                </configuration>\n            </plugin>\n\n            <!-- Maven Compiler Plugin -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                    <encoding>UTF-8</encoding>\n                </configuration>\n            </plugin>\n\n            <!-- Maven Surefire Plugin for running tests -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <version>3.1.2</version>\n                <configuration>\n                    <includes>\n                        <include>**/*Test.java</include>\n                        <include>**/*Tests.java</include>\n                    </includes>\n                </configuration>\n            </plugin>\n\n            <!-- Maven Failsafe Plugin for integration tests -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-failsafe-plugin</artifactId>\n                <version>3.1.2</version>\n                <configuration>\n                    <includes>\n                        <include>**/*IT.java</include>\n                        <include>**/*IntegrationTest.java</include>\n                    </includes>\n                </configuration>\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>integration-test</goal>\n                            <goal>verify</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n\n            <!-- Maven Resources Plugin -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-resources-plugin</artifactId>\n                <version>3.3.1</version>\n                <configuration>\n                    <encoding>UTF-8</encoding>\n                </configuration>\n            </plugin>\n\n            <!-- Maven JAR Plugin -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.3.0</version>\n                <configuration>\n                    <archive>\n                        <manifest>\n                            <addClasspath>true</addClasspath>\n                            <mainClass>com.example.connectionpool.DatabaseConnectionPoolApplication</mainClass>\n                        </manifest>\n                    </archive>\n                </configuration>\n            </plugin>\n\n            <!-- JaCoCo Plugin for code coverage -->\n            <plugin>\n                <groupId>org.jacoco</groupId>\n                <artifactId>jacoco-maven-plugin</artifactId>\n                <version>0.8.10</version>\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>prepare-agent</goal>\n                        </goals>\n                    </execution>\n                    <execution>\n                        <id>report</id>\n                        <phase>test</phase>\n                        <goals>\n                            <goal>report</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n\n    <!-- Profiles for different environments -->\n    <profiles>\n        <!-- Development Profile -->\n        <profile>\n            <id>dev</id>\n            <activation>\n                <activeByDefault>true</activeByDefault>\n            </activation>\n            <properties>\n                <spring.profiles.active>dev</spring.profiles.active>\n            </properties>\n        </profile>\n\n        <!-- Production Profile -->\n        <profile>\n            <id>prod</id>\n            <properties>\n                <spring.profiles.active>prod</spring.profiles.active>\n            </properties>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>org.springframework.boot</groupId>\n                        <artifactId>spring-boot-maven-plugin</artifactId>\n                        <configuration>\n                            <jvmArguments>\n                                -XX:+UseG1GC\n                                -XX:MaxGCPauseMillis=200\n                                -Xms512m\n                                -Xmx2g\n                                -XX:+HeapDumpOnOutOfMemoryError\n                            </jvmArguments>\n                        </configuration>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n\n        <!-- Testing Profile -->\n        <profile>\n            <id>test</id>\n            <properties>\n                <spring.profiles.active>test</spring.profiles.active>\n            </properties>\n            <dependencies>\n                <dependency>\n                    <groupId>org.testcontainers</groupId>\n                    <artifactId>junit-jupiter</artifactId>\n                    <scope>test</scope>\n                </dependency>\n            </dependencies>\n        </profile>\n    </profiles>\n\n    <!-- Repositories (if needed for specific dependencies) -->\n    <repositories>\n        <repository>\n            <id>spring-releases</id>\n            <name>Spring Releases</name>\n            <url>https://repo.spring.io/release</url>\n            <snapshots>\n                <enabled>false</enabled>\n            </snapshots>\n        </repository>\n    </repositories>\n\n    <pluginRepositories>\n        <pluginRepository>\n            <id>spring-releases</id>\n            <name>Spring Releases</name>\n            <url>https://repo.spring.io/release</url>\n            <snapshots>\n                <enabled>false</enabled>\n            </snapshots>\n        </pluginRepository>\n    </pluginRepositories>\n\n</project>\n\n\n```",
  "timeout": 180
}